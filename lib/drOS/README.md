
drOS - 专为单片机而生的嵌入式实时内核

---

drOS, 如其名所言，是 dr 开发的 OS。那么 dr 为什么要开发一个 OS 呢？

因为在嵌入式领域，缺乏一个专门为现代 C++ 开发的多任务系统。

所谓现代C++，是指 c++23。

c++23 是最适合嵌入式开发的语言，没有之一。
因为 c++23 解决了嵌入式开发的一个痛点：语言级的协程支持。

要使用 c++23 的协程，编译器和库缺一不可。编译器提供了协程的语法糖，库实现了协程的接口。

现有的协程库，都是根植于桌面操作系统的，需要使用 Windows 或 Linux 这样的操作系统才能运行。而在嵌入式领域，我们需要一个更加短小精湛的协程实现。

drOS, 被分分成了3个部分。

其一曰 执行器。由 asio 作者提出的 std.executor 概念浓缩而来。其作用，就是执行处于“就绪状态”的函数对象。并内置了一个基于时间的超时触发系统。有了这个执行器，就可以方便的向执行器“投递”函数对象，从而被执行。
利用其自带的基于时间的超时触发系统，可以很方便的设置一个超时投递的函数对象，从而实现定时任务。

其二曰 无栈协程库。基于 c++23 的协程功能实现。这个无栈协程库提供了将协程转化为函数对象的机制，从而可以被执行器调度执行。因而可以从容的在协程代码里调用 ```co_await co_delay(ms)``` 借助执行器实现优雅的睡眠。同时提供了基于无栈协程的协程间通信组件，如消息列队，信号量。

其三曰 有栈协程库(协作式多线程)。基于 boost.fcontext 的汇编代码实现。同样提供了有栈协程转函数对象的机制，从而可以被执行器调度执行。因而可以从容的在协程代码里调用 ```thread_delay(ms)``` 借助执行器实现优雅的睡眠。同时提供了基于有栈协程的线程间通信组件，如消息列队，信号量。

三大组件通力合作，就诞生了 drOS。
作为一个嵌入式系统，它却并不侵入你的代码。他不接管启动过程，也不接管 cpu 调度。
要使用他，只需要在自己原有的 while(1){ xxx } 循环里，添加上 drOS::loop_once() 的调用即可。



